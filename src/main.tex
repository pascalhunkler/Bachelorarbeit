\documentclass{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{algorithm, algorithmic}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{textgreek}

\title{Analyse der Druckberechnung mithilfe einer Zustandsgleichung im Vergleich zur Lösung eines Gleichungssystems in SPH- Flüssigkeitssimulationen}
\author{Pascal Hunkler}
\date{May 2022}

\begin{document}

\maketitle

\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

\tableofcontents

\chapter{Abstract}
\chapter{Einleitung}
\chapter{Grundlagen}
\section{Navier-Stokes-Gleichung und Flüssigkeitssimulationen}
Dieser Abschnitt behandelt die Navier-Stokes-Gleichung, welche die Grundlage dafür bildet, Flüssigkeitssimulationen zu realisieren.
Sie beschreibt die Änderungsrate der Geschwindigkeit eines kleinen volumetrischen Flüssigkeitelements.
Für die Navier-Stokes-Gleichung gibt es verschiedene Formen, die auf den eulerschen Ansatz oder den lagrangeschen Ansatz beruhen.
Diese Arbeit beschäftigt sich im Wesentlichen auf lagrangesche, partikelbasierte Simulationen,
der Vollständigkeit wegen wird jedoch auch noch kurz auf eulersche, gitterbasierte Ansätze eingegangen.
Die Inhalte dieses Abschnitts beziehen sich auf Ihmsen et al. \cite{ihmsen_sph_2014}.
\subsection{Partikelbasierte Simulation}
In einer partikelbasierten Flüssigkeitssimulation wird die Flüssigkeit in so genannte Partikel unterteilt,
die sich mit der Flüssigkeit mitbewegen. Jedes Partikel nimmt ein Teilvolumen der Flüssigkeit ein und besitzt eine Masse.
In einem partikelbasierten Ansatz kann die Navier-Stokes-Gleichung wie folgt beschrieben werden:
\begin{equation}
    \frac{d\textbf{v}_i}{dt} = -\frac{1}{\rho_i} \nabla p_i + \nu \nabla^2 \textbf{v}_i + \frac{\textbf{F}_i^{other}}{m_i}
\end{equation}
Sie zeigt die verschiedenen Beschleunigungen, die auf ein Partikel $i$ wirken, und damit die Geschwindigkeit des Partikels beeinflussen:
Die Druckbeschleunigung $-\frac{1}{\rho_i} \nabla p_i$,
die Viskositätsbeschleunigung $\nu \nabla^2 \textbf{v}_i$
und der Einfluss anderer Kräfte $\frac{\textbf{F}_i^{other}}{m_i}$,
wie beispielsweise die Gravitation.
Ziel einer partikelbasierten Simulation ist es, die verschiedenen Beschleunigungen zu berechnen,
um die Geschwindigkeiten und Positionen der Partikel stets anzupassen.
Eine Methode, um die Beschleunigungen an den Partikeln zu berechnen ist Smoothed Particle Hydrodynamics (SPH),
welches im nächsten Abschnitt vorgestellt wird.

\subsection{Gitterbasierte Simulation}

\section{SPH}
Das Konzept Smoothed Particle Hydrodynamics (SPH),
ursprünglich formuliert von Lucy \cite{lucy_numerical_1977} und unabhängig davon von Monaghan und Gingold \cite{gingold_smoothed_1977},
entstand ursprünglich aus dem Bereich der Astrophysik, wird aber heute auch in diversen anderen Bereichen,
unter anderem auch der Computergrafik angewandt.
Mithilfe von SPH kann durch Diskretisierung und Berechnung von Größen wie der Druckbeschleunigung oder der Viskositätsbeschleunigung
die Navier-Stokes-Gleichung gelöst werden.
Es eignet sich daher gut für partikelbasierte Simulationen.

\subsection{Diskretisierung mit SPH}
Die Inhalte dieses Abschnittes basieren hauptsächlich auf den Arbeiten
von Monaghan \cite{monaghan_smoothed_2005}, von Price \cite{price_smoothed_2012} und von Koshier et al. \cite{koschier_smoothed_2020}.
Für eine beliebige skalare Variable A gilt die Identität
\begin{equation}
    \label{equation:dirac_integral}
    A(\textbf{x}) = \int A(\textbf{x}') \delta(\textbf{x} - \textbf{x}') d\textbf{x}'
\end{equation}
$\delta$ ist hierbei die Dirac'sche Deltafunktion, die definiert ist als
\begin{equation}
    \delta(\textbf{x}) = \begin{cases}
        \infty, &\text{falls } \textbf{x} = 0\\
        0, &\text{sonst}
    \end{cases}
\end{equation}
Die Dirac'sche Deltafunktion in Gleichung \ref{equation:dirac_integral} kann mithilfe einer glättenden Kernelfunktion $W$ mit endlicher Breite $h$ approximiert werden.
\begin{equation}
    \label{equation:approximation_by_kernel}
    A(\textbf{x}) = \int A(\textbf{x}') W(\textbf{x} - \textbf{x}', h) d\textbf{x}' + O(h^2)
\end{equation}
Damit die Approximation aus Gleichung \ref{equation:approximation_by_kernel} gültig ist, muss $W$ folgende Eigenschaften besitzen:
\begin{align}
    &\int_{\mathbb{R}^d} W(\textbf{x}', h)dv' = 1 & \text{(Normalisierung)}\\
    &\lim_{h \to 0} W(\textbf{x}, h) = \delta(\textbf{x}) & \text{(Dirac-\textdelta)}
\end{align}
Weitere wünschenswerte Eigenschaften der Kernelfunktion $W$ sind:
\begin{align}
    &W(\textbf{x}, h) \geq 0 & \text{(Positivität)}\\
    &W(\textbf{x}, h) = W(-\textbf{x}, h) & \text{(Symmetrie)}\\
    &W(\textbf{x}, h) = 0 \text{ für } \| \textbf{x} \| \geq \hbar & \text{(Kompakter Support)}
\end{align}
$\forall \textbf{x} \in \mathbb{R}^d, h \in \mathbb{R}^+$, während $\hbar$ der Kernelsupport ist.
Eine beliebte Kernelfunktion ist der Cubic Spline Kernel \cite{monaghan_smoothed_1992}.
Er ist definiert als
\begin{equation}
    W(\textbf{x}, h) = \sigma_d \begin{cases}
        (2-q)^3 - 4(1-q)^3, &\text{für } 0 \leq q \leq 1\\
        (2-q)^3, &\text{für } 1 \leq q \leq 2\\
        0, &\text{sonst}
    \end{cases}
    %    6(q^3 - q^2) + 1, &\text{für } 0 \leq q \leq \frac{1}{2}\\
    %    2(1 - q)^3, &\text{für } \frac{1}{2} < q \leq 1\\
    %    0, &\text{sonst}
    %\end{cases}
\end{equation}
mit $q = \frac{1}{h}\|\textbf{x}\|$. Der Kernelnormalisierungsfaktor $\sigma_d$ ist abhängig von der Dimension $d$
und beträgt für $d = 1,2,3$ $\sigma_1 = \frac{1}{6h}, \sigma_2 = \frac{5}{14\pi h^2}, \sigma_1 = \frac{1}{4\pi h^3}$.
In der Literatur gibt es verschiedene Formulierungen für den Cubic Spline Kernel, die sich im Wesentlichen in der Parametrisierung unterscheiden.
Der Vorteil dieser Kernelfunktion ist, dass die Eigenschaften zu Positivität, Symmetrie, und kompakten Support, erfüllt werden.
Zudem erzielt Cubic Spline trotz seiner Einfachkeit gute Ergebnisse.

Um die Interpolation aus Gleichung \ref{equation:approximation_by_kernel} bei einer Flüssigkeit zu diskretisieren,
wird die Flüssigkeit in mehrere Partikel unterteilt. Jedes Partikel $f$ besitzt eine Masse $m_f$, Dichte $\rho_f$ und Position $\textbf{x}_f$.
Der Wert von $A$ an einem Partikel $f$ wird notiert als $A_f$.
Der Integral aus Gleichung \ref{equation:approximation_by_kernel} kann nun durch eine Summe, und die Masse $\rho dV$ durch die Partikelmasse $m_f$ ersetzt werden.
\begin{align}
    A(\textbf{x}) &= \int \frac{A(\textbf{x}')}{\rho(\textbf{x}')} W(\textbf{x} - \textbf{x}', h) \rho(\textbf{x}')d\textbf{x}'\\
                  &\approx \sum_{f_f} m_{f_f} \frac{A_{f_f}}{\rho_{f_f}} W(\textbf{x}_f - \textbf{x}_{f_f}, h) = A_f
\end{align}
$f_f$ sind hierbei alle Partikel der Flüssigkeit.
Da beispielsweise der Cubic Spline Kernel einen Kernelsupport von $2h$ besitzt, muss hier nur über Partikel $f_f$ summiert werden, die in direkter Nachbarschaft sind,
da die Kernelfunktion für Partikel, die weiter als $2h$ von dem Partikel $f$ entfernt sind, null ist.
Daher ist die Eigenschaft, dass der Support der Kernelfunktion kompakt ist, wünschenswert.

\subsection{SPH in partikelbasierten Simulationen}
% \section{Nachbarschaftssuche}
% \subsection{Uniformes Gitter}
% \subsection{Weitere Methoden zur effizienteren Nachbarschaftssuche}
% \section{Grenzbehandlung}
\chapter{Druckberechnung}
\section{Druckberechnung mit einer Zustandsgleichung}
\section{Druckberechnung mit IISPH}
\chapter{Implementierung}
\section{Programmierumgebung}
\section{Architektur der Software}
\section{Kernelfunktion, Kernelgradient}
\section{Nachbarschaftssuche}
\subsection{Uniformes Gitter Aufbau}
\subsection{Bestimmung der Nachbarn mithilfe des uniformen Gitters}
\subsection{}
\section{Simulationsschritt}
\subsection{Berechnung der Dichte}
\subsection{Berechnung des Drucks}
\subsection{Berechnung der Druckbeschleunigung}
\subsection{Berechnung der restlichen Beschleunigungen}
\section{Visualisierung}
\chapter{Analyse}
\section{Szenarien}
\section{Rechen- und Speicheraufwand}
\section{Einfluss des Zeitschritts}
\section{}
\chapter{Fazit und Ausblick}
\chapter{Literaturverzeichnis}
\bibliographystyle{alpha}
\bibliography{literaturverzeichnis}

\begin{algorithm}
\caption{Simulationsschritt}
\label{alg:simulationsschritt}
\begin{algorithmic}[1]
    \STATE Determine neighbors of each particle
    \STATE Compute density $\rho_f$ of each fluid particle using algorithm \ref{alg:dichte}
    \STATE Compute non-pressure accelerations $\textbf{a}_f^n$ using algorithm \ref{alg:restliche_beschleunigung}
    \FORALL{fluid particle f}
        \STATE $\textbf{v}_f^* \gets \textbf{v}_f + \Delta t \textbf{a}_f^n$
    \ENDFOR
    \STATE Compute pressure $p_f$ of each fluid particle using algorithm \ref{alg:druck}
    \STATE Compute pressure accelerations $\textbf{a}_f^p$ using algorithm \ref{alg:druckbeschleunigung}
    \FORALL{fluid particle f}
        \STATE $\textbf{v}_f \gets \textbf{v}_f^* + \Delta t \textbf{a}_f^p$
    \ENDFOR
    \FORALL{fluid particle f}
        \STATE $\textbf{x}_f \gets \textbf{x}_f + \Delta t \textbf{v}_f$
    \ENDFOR
    \STATE 
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Berechnung der Dichte der Partikel}
\label{alg:dichte}
\begin{algorithmic}
    \FORALL{particle i}
        \IF{particle i belongs to the boundary}
            \STATE continue
        \ENDIF
        \STATE $\rho_i \gets 0$
        \FORALL{neighbor j of particle i}
            \STATE $\rho_i \gets \rho_i + W_{ij}$
        \ENDFOR
        \STATE $\rho_i \gets \rho_i \cdot m_f$
    \ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Berechnung der restlichen Beschleunigungen}
\label{alg:restliche_beschleunigung}
\begin{algorithmic}
    \FORALL{particle i}
    \IF{particle i belongs to the boundary}
        \STATE $\textbf{a}_i^n \gets \begin{pmatrix}0 & 0 \end{pmatrix}^\intercal$
        \STATE continue
    \ENDIF
    \STATE $\textbf{acc}_g \gets \begin{pmatrix}0 &-9.81 \end{pmatrix}^\intercal$
    \STATE $\textbf{acc}_v \gets \begin{pmatrix}0 & 0 \end{pmatrix}^\intercal$
    \STATE
    \STATE \text{// Viskositätsbeschleunigung an Partikel i}
    \FORALL{neighbor j of particle i}
        \IF{particle j belongs to the boundary}
            \STATE $\textbf{acc}_v \gets \textbf{acc}_v + \frac{1}{\rho_i} \frac{(\textbf{v}_i - \textbf{v}_j)(\textbf{x}_i - \textbf{x}_j)}{(\textbf{x}_i - \textbf{x}_j)(\textbf{x}_i - \textbf{x}_j) + 0.01h^2} \cdot \nabla W_{ij}$
        \ELSE
            \STATE $\textbf{acc}_v \gets \textbf{acc}_v + \frac{1}{\rho_j} \frac{(\textbf{v}_i - \textbf{v}_j)(\textbf{x}_i - \textbf{x}_j)}{(\textbf{x}_i - \textbf{x}_j)(\textbf{x}_i - \textbf{x}_j) + 0.01h^2} \cdot \nabla W_{ij}$
        \ENDIF
    \ENDFOR
    \STATE $\textbf{acc}_v \gets 2\nu m_f \cdot \textbf{acc}_v$
    \STATE
    \STATE $\textbf{a}_i^n \gets \textbf{acc}_g + \textbf{acc}_v$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Berechnung der Druckbeschleunigungen}
\label{alg:druckbeschleunigung}
\begin{algorithmic}
    \FORALL{particle i}
    \IF{particle i belongs to the boundary}
        \STATE $\textbf{a}_i^p \gets \begin{pmatrix}0 & 0 \end{pmatrix}^\intercal$
        \STATE continue
    \ENDIF
    \STATE $\textbf{acc}_p \gets \begin{pmatrix}0 & 0 \end{pmatrix}^\intercal$
    \STATE
    \STATE \text{// Druckbeschleunigung an Partikel i}
    \FORALL{neighbor j of particle i}
        \IF{particle j belongs to the boundary}
            \STATE $\textbf{acc}_p \gets \textbf{acc}_p - \left(\frac{p_i}{\rho_i^2} + \frac{p_i}{\left(\rho_f^0\right)^2}\right) \cdot \nabla W_{ij}$ 
        \ELSE
            \STATE $\textbf{acc}_p \gets \textbf{acc}_p - \left(\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2}\right) \cdot \nabla W_{ij}$
        \ENDIF
    \ENDFOR
    \STATE $\textbf{acc}_p \gets \textbf{acc}_p \cdot m_f$
    \STATE
    \STATE $\textbf{a}_i^p \gets \textbf{acc}_p$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Berechnung des Drucks der Partikel}
\label{alg:druck}
\begin{algorithmic}[1]
    \FORALL{fluid particle f}
        \STATE $A_{ff} \gets -\Delta t^2 \frac{m_f^2}{\rho_f^2} \cdot \left(\sum_{f_f}\nabla W_{ff_f} \nabla W_{ff_f} + \sum_{f_b}\nabla W_{ff_b} \nabla W_{ff_b}\right)$
        \STATE $s_f \gets \rho_f^0 - \rho_f - m_f \Delta t \left(\sum_{f_f}(\textbf{v}_f^* - \textbf{v}_{f_f}^*) \nabla W_{ff_f} + \sum_{f_b}\textbf{v}_f^* \nabla W_{ff_b}\right)$
        \STATE $p_f \gets 0$
    \ENDFOR
     \STATE $e \gets \infty$
     \WHILE{$e \geq 0.001$}
        \STATE $e \gets 0$
        \STATE Compute pressure accelerations $\textbf{a}_f^p$ using algorithm \ref{alg:druckbeschleunigung}
        \FORALL{fluid particle f}
            \STATE $(\textbf{A}\textbf{p})_f \gets m_f \Delta t^2\left(\sum_{f_f}(\textbf{a}_f^p - \textbf{a}_{f_f}^p) \nabla W_{ff_f} + \sum_{f_b}\textbf{a}_f^p \nabla W_{ff_b}\right)$
            \IF{$f$ has no neighbors}
                \STATE $(\textbf{A}\textbf{p})_f \gets 0$
            \ENDIF
            \STATE $p_f \gets \max(p_f + \omega \frac{s_f - (\textbf{A}\textbf{p})_f}{\textbf{A}_{ff}}, 0)$
            \STATE $e \gets e + \frac{(\textbf{A}\textbf{p})_f - s_f}{\rho_f^0}$
        \ENDFOR
        \STATE $e \gets \frac{e}{n}$
    \ENDWHILE
\end{algorithmic}
\end{algorithm}

\end{document}
